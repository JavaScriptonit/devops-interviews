# Список вопросов:

## Собеседование со Сбер Devices:
https://hh.ru/vacancy/83405120?hhtmFrom=employer_vacancies


# Terraform.

## 1. Что будет если 2 разработчика обновят файл .tfstate одновременно?

https://ru.hexlet.io/courses/terraform-basics/lessons/remote-state/theory_unit

`Terraform` хранит текущее состояние инфраструктуры в файле с расширением `.tfstate`. При выполнении операций `Terraform` идет в файл состояния и проверяет, какая инфраструктура уже развернута. На основе того, что есть в состоянии и что описано в проекте, `Terraform` понимает, что нужно сделать — создать инфраструктуру или изменить.

Если организовать этот процесс через `git-репозиторий`, нужно сначала обновить инфраструктуру, затем добавить коммит с новым `tfstate` и отправить его в удаленный репозиторий. Коллега должен получить из репозитория актуальный `tfstate`, внести свои изменения, и в свою очередь отправить изменения в коде `Terraform` и новый файл состояния в `Git`

### `Terraform remote backends`:

В терминологии Terraform backend — это решение, которое отвечает за хранение состояния. Если состояние хранится удаленно — это `remote backend`.

При использовании remote backend Terraform сохраняет состояние в удаленное хранилище, а локально в tfstate хранит только информацию об этом удаленном хранилище.

В качестве хранилища может выступать любое облачное объектное хранилище по типу `Amazon S3: Google Cloud Storage`, `Azure Storage`, `Yandex Cloud Storage` и другие подобные решения. Также Terraform может использовать для удаленного хранения состояния HTTP-сервер, базу данных PostgreSQL или облачную платформу Terraform Cloud.

В схеме с remote backend при выполнении любых операций над инфраструктурой Terraform будет обращаться к удаленному файлу состояния, блокировать его на время выполнения изменений, затем перезаписывать этот файл с учетом внесенных изменений

#### Как настроить хранение состояния в S3:
Подготавливаем облако для хранения состояния (Создадим в облаке S3-хранилище yc-hexlet-state объемом 10МБ. Этого хватит для хранения состояния надолго):
```
yc storage bucket create --name yc-hexlet-state --max-size 10000000
```
сделать табличку в облачной базе данных, где Terraform будет фиксировать блокировки состояния:
```
yc ydb database create terraform-state-lock --serverless

done (7s)
id: etnpkn3gs4s56qk9g7kf
folder_id: ...
created_at: ...
name: terraform-state-lock
...
document_api_endpoint: https://docapi.serverless.yandexcloud.net/ru-central1/b1gjrod3dvqni46u3paj/etnpkn3gs4s56qk9g7kf
```
Сохраним document_api_endpoint, он нам понадобится при конфигурации Terraform («Создать таблицу» и создадим документную таблицу lock с колонкой LockID типа String, которая будет являться ключом партиционирования)

через YandexCLI создадим сервисный аккаунт hexlet-remote, который будет сохранять состояние Terraform в облачное хранилище
```
yc iam service-account create --name hexlet-remote --description "SA to manage terraform state"

id: ajejk11p9ls1vvhc12mb
folder_id: ...
created_at: ...
name: hexlet-remote
description: SA to manage terraform state
```

Создадим в проекте файл backend.tf и вставим туда блок backend, описывающий хранение состояния:
```
terraform {
  backend "s3" {
    endpoint                    = "storage.yandexcloud.net"
    region                      = "ru-central1"
    bucket                      = "yc-hexlet-state"
    key                         = "hexlet-remote-state"
    access_key                  = "YCABX6vQXtCjoKu_oB7QabuZO"
    secret_key                  = "YCOL4xZ1tdpduS46z_YTlvDzYUwv8xBK_UuRq18m"
    dynamodb_endpoint           = "https://docapi.serverless.yandexcloud.net/ru-central1/b1gjrod3dvqni46u3paj/etnpkn3gs4s56qk9g7kf"
    dynamodb_table              = "lock"
    skip_region_validation      = true
    skip_credentials_validation = true
  }
}
```
Перенести локальный файл с состоянием в удаленное хранилище:
```
terraform init -migrate-state
```

Так мы с помощью удаленного хранения состояния в S3-хранилище и блокировки состояния в YDB добились того, что:

Состояние инфраструктуры всегда будет одинаковым и актуальным у всей команды. Локально в .tfstate проекта будет храниться только адрес удаленного бэкенда
Не возникнут конфликты одновременного обновления инфраструктуры двумя или более членами команды
Мы настроили удаленное хранение состояния. Осталось позаботиться о безопасности и о том, чтобы ключи для нашего хранилища не утекли в сеть.

## 2. Отличие Git stash от Git rebase?

### Git stash:

https://www.atlassian.com/ru/git/tutorials/saving-changes/git-stash

Команда `git stash` позволяет на время «сдать в архив» (или отложить) изменения, сделанные в рабочей копии, чтобы вы могли применить их позже. Откладывание изменений полезно, если вам необходимо переключить контекст и вы пока не готовы к созданию коммита.

Теперь вы можете вносить изменения, создавать новые коммиты, переключаться между ветками и выполнять другие операции Git. По необходимости отложенные изменения можно будет применить позже.

Отложенные изменения сохраняются в локальном репозитории Git и не передаются на сервер при выполнении команды push.

```
$ git status
Changes to be committed:
    new file:   style.css

$ git stash
Saved working directory and index state WIP on main: 5002d47 our new homepage
HEAD is now at 5002d47 our new homepage

$ git status
On branch main
nothing to commit, working tree clean
```

Применение отложенных изменений:
```
git stash pop
```

Управление несколькими наборами отложенных изменений:
```
$ git stash list
stash@{0}: WIP on main: 5002d47 our new homepage
stash@{1}: WIP on main: 5002d47 our new homepage
stash@{2}: WIP on main: 5002d47 our new homepage
```

`git stash show` - Просмотр различий между наборами отложенных изменений

`git stash branch` - Создание ветки из отложенных изменений

`git stash drop stash@{1}` - Удаление отложенных изменений

### Git rebase:

https://www.atlassian.com/ru/git/tutorials/rewriting-history/git-rebase

Перебазирование — это процесс перемещения последовательности коммитов к новому базовому коммиту или их объединение. Операцию перебазирования удобнее всего применить и отобразить в контексте создания функциональных веток. В общих чертах процесс можно представить следующим образом:

С точки зрения содержимого перебазирование — это замена одного коммита в основании ветки на другой, в результате чего создается впечатление, что ветка получила новое начало. В процессе этой операции Git создает новые коммиты и применяет их к указанному основанию, поэтому важно понимать, что в действительности ветка всегда состоит из совершенно новых коммитов.

`Интерактивное перебазирование позволяет полностью контролировать состояние истории проекта.` Это дает разработчикам большую свободу, поскольку они могут зафиксировать засоренную историю, не отрываясь от написания кода, и очистить ее позже.

Большинство разработчиков используют интерактивное перебазирование, чтобы придать функциональной ветке аккуратность перед слиянием с основной базой кода. Они могут склеить незначительные коммиты, удалить устаревшие элементы и в целом навести порядок в ветке, прежде чем выполнить перенос в «официальную» историю проекта. Со стороны будет казаться, что для разработки функции потребовалось лишь несколько коммитов и тщательное планирование.

Оценить эффективность интерактивного перебазирования можно, взглянув на получившуюся историю ветки main. В глазах окружающих вы будете блестящим разработчиком, который внедрил новую функцию с первого раза и без лишних коммитов. `Так интерактивное перебазирование помогает поддерживать порядок в истории проекта, а также сохраняет целесообразность каждого ее элемента.`

## 3. Что такое Git Cherry pick?

https://www.atlassian.com/ru/git/tutorials/cherry-pick#

`git cherry-pick` — это полезная команда, с помощью которой можно выборочно применить коммиты Git к текущей рабочей ветке HEAD. С ее помощью можно выбрать коммит из одной ветки и применить его к другой. Команда `git cherry-pick` — это удобный способ отменить изменения. Например, если коммит попал в ветку по ошибке, вы можете переключиться на нужную ветку и выполнить перенос.

Пользоваться командой `git cherry-pick` удобно, однако это не всегда оптимально. Она может привести к дублированию коммитов, поэтому нередко разработчики предпочитают обычное слияние. Таким образом, можно сказать, что команда `git cherry-pick` — средство эффективное, но узконаправленное.

Пример использования:
Если был обнаружен баг, важно как можно скорее предоставить исправление конечным пользователям. Рассмотрим пример, когда разработчик начинает создавать новую функцию. `В ходе работы обнаруживается существующий баг`, и разработчик создает специальный коммит для его исправления. Этот `коммит можно перенести прямо в основную ветку (main)`, чтобы исправить баг, прежде чем от него пострадают другие пользователи.

# CI/CD:

## 4. Что такое CI/CD?

Дополнить вопросы.


# Monitoring:

## 5. Мониторинг. Какой стек использовал?

Примеры использования мониторинга k8s и приложений на Linux:

### Использование стека grafana + prometheus + node exporter:
Для мониторинга кластера k8s и приложений на Linux. Этот стек позволяет собирать метрики с кластера k8s и отображать их в графическом виде с помощью Grafana. Node exporter собирает метрики с узлов кластера, а Prometheus хранит их и обеспечивает возможность запросов.

Файл конфигурации для настройки сбора метрик Prometheus:
```
prometheus.yml
```
Команда для запуска Grafana:
```
docker run -d --name=grafana -p 3000:3000 grafana/grafana
```

### Использование Instana + Instana agents:
Для мониторинга приложений на Linux. Instana предоставляет возможность мониторинга приложений в реальном времени с помощью агентов, установленных на хостах.

Команда для установки агента Instana на хосте Linux:
```
wget -O - https://setup.instana.io/agent | sh -s YOUR_AGENT_KEY
```
Файл конфигурации для настройки агента Instana:
```
instana-config.yaml
```
Команда для запуска мониторинга в реальном времени:
```
instana-agent start
```

# Logs:

## 6. Логирование. Какой стек использовал?

Примеры использования логирования k8s и приложений на Linux:

### Использование Loki + grafana:
Для сбора и отображения логов приложений на Linux. Loki - это система сбора и отображения логов, которая интегрируется с Grafana для отображения логов в удобном виде.

Команда для установки Loki в кластере k8s:
```
helm repo add grafana https://grafana.github.io/helm-charts
helm install loki grafana/loki-stack
```
Файл конфигурации для настройки сбора логов Loki:
```
loki-config.yaml
```

## 7. Хранение логов и метрик:

`При выборе места хранения логов и метрик учитывайте требования к безопасности, резервному копированию и доступности данных`. Также убедитесь, что выбранное решение соответствует требованиям по производительности и масштабируемости.

Для хранения больших объемов данных можно использовать специализированные хранилища, такие как `Amazon S3`, `Google Cloud Storage` или `MinIO`.

Использование базы данных для хранения логов и метрик:

В качестве базы данных можно использовать `InfluxDB`, которая специализируется на хранении временных рядов данных, что подходит для хранения метрик.
Для хранения логов можно использовать `Elasticsearch`, который также позволяет выполнять полнотекстовый поиск и анализ логов.



# Вопросы из записей из iCloud - Виртуальный ассистент:
(Тех собес Сбер devices 1/2 и Тех собес Сбер devices 2/2)

## 1. Расскажие о себе (2 года). Задачи, которыми занимался сам, но не команда.
Смарт-трейд. Лид автоматизации и джун devops. 
Задачи: 
  1. подготовка CI/CD, 
  2. написание Dockerfile, docker-compose.yml.
  3. конфигурация раннеров
  4. развитие инфраструктуры для прогона тестов (физ сервера Linux Ubuntu 20.04, 22.04. Сборка билдов, запуск тестов в docker в VNC).
Инструменты: 
  1. Gitlab + gitlab runner + gitlab ci
  2. Docker
  3. Selenoid, selenoid-ui, ggr, ggr-ui
  4. Allure-server

МТС-Банк. middle-Devops.
Задачи:
  1. мониторинг бд, серверов, приложений, docker контейнеров и k8s кластера
  2. адмнистрирование linux серверов и ios 
  3. развитие инфраструктуры для прогона тестов, работы приложений и бд
  4. развитие аппиум фермы
  5. деплои в k8s кластер и конфигурация helm chart'ов (ingress, pods, services, rs, deployment)
  6. написание пайплайнов, баш скриптов, ansible-playbook

## 2. На чем был CI/CD в проектах?
Jenkins, GitHub Actions, GitLab

## 3. Какие аналоги HELM ты знаешь?
1. ### Kustomize:
    1. Похож на Dockerfile - kustomization.yaml
        1. После создания service.yaml + deployment.yaml -> kustomization.yaml кастомизирует их с заданными значениями
    2. Аналог helm
    3. Встроен в kubectl (v1.14+):
        1. kubectl apply -k === применит kustomize-манифесты
        2. kubectl delete -k === удалит их
        3. kubectl kustomize соберёт манифесты и выведет на экран
    4. Не шаблонизирует как helm
2. ### Jsonnet:
    1. Jsonnet - это ЯП и инструмент для генерации JSON и других форматов данных. Он позволяет создавать и управлять структурированными данными с помощью более компактного и выразительного синтаксиса.
    2. Основан на JSON
    3. Можно конвертировать в YAML
    4. Используется с ЯП:
        1. C
        2. Python
        3. Go
        4. PHP
        5. Ruby
    5. Jsonnet может предоставить более гибкий и мощный подход к генерации конфигураций, чем Helm

## 4. 




## Продолжить "Тех собес Сбер devices 1/2" с 12:13 мин