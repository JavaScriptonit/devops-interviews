# Список вопросов:

## Собеседование со Сбер Devices:
https://hh.ru/vacancy/83405120?hhtmFrom=employer_vacancies


# Terraform.

1. ## Что будет если 2 разработчика обновят файл .tfstate одновременно?

https://ru.hexlet.io/courses/terraform-basics/lessons/remote-state/theory_unit

`Terraform` хранит текущее состояние инфраструктуры в файле с расширением `.tfstate`. При выполнении операций `Terraform` идет в файл состояния и проверяет, какая инфраструктура уже развернута. На основе того, что есть в состоянии и что описано в проекте, `Terraform` понимает, что нужно сделать — создать инфраструктуру или изменить.

Если организовать этот процесс через `git-репозиторий`, нужно сначала обновить инфраструктуру, затем добавить коммит с новым `tfstate` и отправить его в удаленный репозиторий. Коллега должен получить из репозитория актуальный `tfstate`, внести свои изменения, и в свою очередь отправить изменения в коде `Terraform` и новый файл состояния в `Git`

### `Terraform remote backends`:

В терминологии Terraform backend — это решение, которое отвечает за хранение состояния. Если состояние хранится удаленно — это `remote backend`.

При использовании remote backend Terraform сохраняет состояние в удаленное хранилище, а локально в tfstate хранит только информацию об этом удаленном хранилище.

В качестве хранилища может выступать любое облачное объектное хранилище по типу `Amazon S3: Google Cloud Storage`, `Azure Storage`, `Yandex Cloud Storage` и другие подобные решения. Также Terraform может использовать для удаленного хранения состояния HTTP-сервер, базу данных PostgreSQL или облачную платформу Terraform Cloud.

В схеме с remote backend при выполнении любых операций над инфраструктурой Terraform будет обращаться к удаленному файлу состояния, блокировать его на время выполнения изменений, затем перезаписывать этот файл с учетом внесенных изменений

#### Как настроить хранение состояния в S3:
Подготавливаем облако для хранения состояния (Создадим в облаке S3-хранилище yc-hexlet-state объемом 10МБ. Этого хватит для хранения состояния надолго):
```
yc storage bucket create --name yc-hexlet-state --max-size 10000000
```
сделать табличку в облачной базе данных, где Terraform будет фиксировать блокировки состояния:
```
yc ydb database create terraform-state-lock --serverless

done (7s)
id: etnpkn3gs4s56qk9g7kf
folder_id: ...
created_at: ...
name: terraform-state-lock
...
document_api_endpoint: https://docapi.serverless.yandexcloud.net/ru-central1/b1gjrod3dvqni46u3paj/etnpkn3gs4s56qk9g7kf
```
Сохраним document_api_endpoint, он нам понадобится при конфигурации Terraform («Создать таблицу» и создадим документную таблицу lock с колонкой LockID типа String, которая будет являться ключом партиционирования)

через YandexCLI создадим сервисный аккаунт hexlet-remote, который будет сохранять состояние Terraform в облачное хранилище
```
yc iam service-account create --name hexlet-remote --description "SA to manage terraform state"

id: ajejk11p9ls1vvhc12mb
folder_id: ...
created_at: ...
name: hexlet-remote
description: SA to manage terraform state
```

Создадим в проекте файл backend.tf и вставим туда блок backend, описывающий хранение состояния:
```
terraform {
  backend "s3" {
    endpoint                    = "storage.yandexcloud.net"
    region                      = "ru-central1"
    bucket                      = "yc-hexlet-state"
    key                         = "hexlet-remote-state"
    access_key                  = "YCABX6vQXtCjoKu_oB7QabuZO"
    secret_key                  = "YCOL4xZ1tdpduS46z_YTlvDzYUwv8xBK_UuRq18m"
    dynamodb_endpoint           = "https://docapi.serverless.yandexcloud.net/ru-central1/b1gjrod3dvqni46u3paj/etnpkn3gs4s56qk9g7kf"
    dynamodb_table              = "lock"
    skip_region_validation      = true
    skip_credentials_validation = true
  }
}
```
Перенести локальный файл с состоянием в удаленное хранилище:
```
terraform init -migrate-state
```

Так мы с помощью удаленного хранения состояния в S3-хранилище и блокировки состояния в YDB добились того, что:

Состояние инфраструктуры всегда будет одинаковым и актуальным у всей команды. Локально в .tfstate проекта будет храниться только адрес удаленного бэкенда
Не возникнут конфликты одновременного обновления инфраструктуры двумя или более членами команды
Мы настроили удаленное хранение состояния. Осталось позаботиться о безопасности и о том, чтобы ключи для нашего хранилища не утекли в сеть.

2. ## Отличие Git stash от Git rebase?

### Git stash:

https://www.atlassian.com/ru/git/tutorials/saving-changes/git-stash

Команда `git stash` позволяет на время «сдать в архив» (или отложить) изменения, сделанные в рабочей копии, чтобы вы могли применить их позже. Откладывание изменений полезно, если вам необходимо переключить контекст и вы пока не готовы к созданию коммита.

Теперь вы можете вносить изменения, создавать новые коммиты, переключаться между ветками и выполнять другие операции Git. По необходимости отложенные изменения можно будет применить позже.

Отложенные изменения сохраняются в локальном репозитории Git и не передаются на сервер при выполнении команды push.

```
$ git status
Changes to be committed:
    new file:   style.css

$ git stash
Saved working directory and index state WIP on main: 5002d47 our new homepage
HEAD is now at 5002d47 our new homepage

$ git status
On branch main
nothing to commit, working tree clean
```

Применение отложенных изменений:
```
git stash pop
```

Управление несколькими наборами отложенных изменений:
```
$ git stash list
stash@{0}: WIP on main: 5002d47 our new homepage
stash@{1}: WIP on main: 5002d47 our new homepage
stash@{2}: WIP on main: 5002d47 our new homepage
```

`git stash show` - Просмотр различий между наборами отложенных изменений
`git stash branch` - Создание ветки из отложенных изменений
`git stash drop stash@{1}` - Удаление отложенных изменений

### Git rebase:

Перебазирование — это процесс перемещения последовательности коммитов к новому базовому коммиту или их объединение. Операцию перебазирования удобнее всего применить и отобразить в контексте создания функциональных веток. В общих чертах процесс можно представить следующим образом:

С точки зрения содержимого перебазирование — это замена одного коммита в основании ветки на другой, в результате чего создается впечатление, что ветка получила новое начало. В процессе этой операции Git создает новые коммиты и применяет их к указанному основанию, поэтому важно понимать, что в действительности ветка всегда состоит из совершенно новых коммитов.

`Интерактивное перебазирование позволяет полностью контролировать состояние истории проекта.` Это дает разработчикам большую свободу, поскольку они могут зафиксировать засоренную историю, не отрываясь от написания кода, и очистить ее позже.

Большинство разработчиков используют интерактивное перебазирование, чтобы придать функциональной ветке аккуратность перед слиянием с основной базой кода. Они могут склеить незначительные коммиты, удалить устаревшие элементы и в целом навести порядок в ветке, прежде чем выполнить перенос в «официальную» историю проекта. Со стороны будет казаться, что для разработки функции потребовалось лишь несколько коммитов и тщательное планирование.

Оценить эффективность интерактивного перебазирования можно, взглянув на получившуюся историю ветки main. В глазах окружающих вы будете блестящим разработчиком, который внедрил новую функцию с первого раза и без лишних коммитов. `Так интерактивное перебазирование помогает поддерживать порядок в истории проекта, а также сохраняет целесообразность каждого ее элемента.`

3. ## Что такое Git Cherry pick?



4. ## Что такое Git VNC?