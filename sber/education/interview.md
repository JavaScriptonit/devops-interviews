# Список вопросов:

## Собеседование со СберОбразованием:
https://hh.ru/vacancy/88499914?hhtmFrom=chat


1. ## Что за последние 2 места работы было самым интеерсным и что больше нравится?
Если Kubernetes - helm и деплои/администрирование/писать операторы/писать автоматизацию чтобы ставить мастера и воркеры/разбирать исходный код?

2. ## Что такое infrastructure as code?
```
"Infrastructure as Code" (IaC) - это подход к управлению инфраструктурой IT-систем с использованием программного кода. Вместо ручного настройки серверов, сетей и других инфраструктурных ресурсов, инженеры описывают всю необходимую инфраструктуру в виде кода, который затем может быть автоматически развернут и управляем с использованием инструментов автоматизации.

Основные принципы Infrastructure as Code включают в себя:

1. Декларативное описание инфраструктуры: Инженеры описывают желаемое состояние инфраструктуры (например, какие серверы должны быть развернуты, какие настройки сети нужны и т.д.) в виде декларативного кода, вместо того, чтобы описывать шаги, необходимые для достижения этого состояния.

2. Использование инструментов автоматизации: Для реализации Infrastructure as Code используются инструменты автоматизации, такие как Ansible, Terraform, Chef, Puppet, CloudFormation, Azure Resource Manager и другие. Эти инструменты позволяют развертывать, настраивать и управлять инфраструктурой с использованием кода.

3. Версионирование и контроль изменений: Код, описывающий инфраструктуру, может быть хранен в системе контроля версий, что позволяет отслеживать изменения, вносимые в инфраструктуру, и возвращаться к предыдущим версиям в случае необходимости.

Преимущества подхода Infrastructure as Code включают повышение скорости развертывания инфраструктуры, повышение надежности и согласованности настроек, а также облегчение масштабирования и управления инфраструктурой.

IaC является ключевым элементом DevOps-практик, так как позволяет автоматизировать процессы управления инфраструктурой и интегрировать их в цикл непрерывной поставки (CI/CD).
```

3. ## Что такое Terraform и что делал на нём?

4. ## Настраивал ли RBAC внутри? ec2? subnet? vpc?

Terraform модуль для создания RBAC-правил - https://habr.com/ru/companies/nixys/articles/649663/
```
Управление доступом на основе ролей (англ. Role Based Access Control, RBAC) 
Начиная с Kubernetes 1.6, RBAC-политики включены по умолчанию
Раньше нам приходилось вручную создавать подобные политики, сервисные аккаунты и пользователей

Данный модуль позволяет создавать сервисные аккаунты и пользователей, а затем генерировать готовые конфигурационные файлы (kubeconfig) для них
Также при помощи данного модуля можно создавать роли, кластерные роли и привязывать их к определенным сервисным аккаунтам, пользователям или группам.
Модуль можно найти в нашем GitHub репозитории - https://github.com/nixys/nxs-k8s-rbac-creator

В этом примере создается роль role-1 в default окружении со следующими правами:
apiVersion: rbac.authorization.k8s.io/v1
kind: Role

Также создается кластерная роль cluster-role-1 со следующими правами:
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole

и cluster-role-2 со следующими правами:
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole

Дополнительно создаются сервисные аккаунты sa-1 в окружении kube-system и sa-2 в окружении default.
Список пользователей для создания берется из поля users в переменной bindings.
То есть в данном случае будут созданы 2 пользователя user-1 и user-2 в группах group-1 и group-2 соответственно.
Также будут созданы 2 RoleBinding cluster-role-2-prefix-1-cluster-role:
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding

и role-1-prefix-1-role следующего вида:
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding

Также будет создан ClusterRoleBinding (соответствует количеству элементов в списке cluster_roles, если type = cluster_role_binding) cluster-role-1-prefix-2:
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding


Данный модуль помог повысить нашу эффективность. Раньше мы могли тратить от 20 до 60 минут на создание RBAC политик. Сейчас же на это уходит от 5 до 10 минут. 
Как правило для проектов мы используем одни и те же роли и кластерные роли. 
То есть можно повторно использовать зараннее созданные файлы с заполненными переменными.
```

K8s инфра в Terraform:
```
https://habr.com/ru/companies/nixys/articles/721404/
Решение — разбиваем конфигурационные файлы по типу описываемых компонентов, т. е. есть главный файл main.tf, где мы объявим провайдера и пропишем доступы к облаку. 

my_project/
├── k8s
│   ├── cluster.tf
│   ├── main.tf
│   ├── node_group.tf
│   ├── service_account.tf
└── network
    ├── external_ip.tf
    ├── main.tf
    ├── security_group.tf
    └── vpc.tf
```

5. ## Что такое модуль Terraform?

1 мая 2023 г. Модули Terraform — это готовые наборы файлов с настройками для облачных сервисов, которые упрощают работу DevOps-инженеров. Также модули помогают избегать дублирования кода. Модули Terraform для сервисов Yandex Cloud уже доступны на GitHub.

6. ## Что такое state Terraform и где его лучше хранить?

Состояние Terraform описывает текущую развернутую инфраструктуру и хранится в файлах с расширением . tfstate . Файл состояния создается после развертывания инфраструктуры и может быть сразу загружен в Object Storage. Загруженный файл состояния будет обновляться после изменений созданной инфраструктуры.

Этот файл используется для отслеживания метаданных и для сопоставления фактических ресурсов с конфигурацией.

По умолчанию этот файл состояния будет находиться локально в папке ваших проектов с именем terraform.tfstate.

Рекомендуется хранить состояния Terraform в высокодоступном удаленном хранилище данных, например, Terraform Cloud, HashiCorp Consul, Amazon S3, Google Cloud Storage (GCS):

```
# Backend
#terraform {
#  backend "local" {
#    path = "terraform.tfstate"
#  }
#}

terraform {
  backend "consul" {
    address  = "consul.example.com:8500"
    scheme   = "http"
    path     = "tf/terraform.tfstate"
    lock     = true
    gzip     = false
  }
}
```

7. ## Назвать все команды из 2ух букв:
```
ls, ps, cd, mw, rm, ln, lp, df, du, fg, ip, su, vi, cp, mc
```

8. ## Что такое код выхода и какие знаешь?
```
1	разнообразные ошибки
2	согласно документации к Bash -- неверное использование встроенных команд
126	вызываемая команда не может быть выполнена
127	"команда не найдена"
128	неверный аргумент команды exit
128+n	фатальная ошибка по сигналу "n"
130	завершение по Control-C
255*	код завершения вне допустимого диапазона
```

9. ## Виртуалка. df -h /home/user1 показывает примонтированный диск на 10Гб из которых 5Гб занято. При создании файла - Ошибка: "No space left on device". Что это может быть?
    1. Ребут: `sudo reboot`
    2. Проверка mount /etc/fstab: `sudo mount -a`
    3. Проверить symbolic link and hard link: `ls -l`
        1. `find . -type l` - найти линки
        2. `readlink имя_символической_ссылки` -  узнать, на что указывает символическая ссылка
    4. Проверить кол-во свободных inodes: `df -T`
    Ответ: Проблема была из-за отсутствия свободных inodes на диске. 2 решения: добавить памяти на диск для увеличения кол-ва инод или изменить файловую систему.

10. ## Сети в Linux. Какие порты сейчас слушаются приложениями? Как проверить?
    1. `netstat -tuln` - позволяет отображать сетевую статистику, включая информацию о сетевых соединениях, прослушиваемых портах и другие сетевые детали
    2. `ss -tuln` - Socket Statistics, отобразит список TCP и UDP портов, которые в данный момент прослушиваются.

11. ## Что такое procfs?
    1. `ProcFS` — специальная файловая система, используемая в Linux, позволяет получить доступ к информации из ядра о системных процессах.
    2. `ps -ef` - выведет список всех запущенных на данный момент процессов:
    ```
    UID        PID  PPID  C STIME TTY          TIME CMD
    root         1     0  0 11:08 ?        00:00:04 init
    root         2     1  0 11:08 ?        00:00:00 [keventd]
    mbutcher  1219  1207  0 12:23 pty/s2   00:00:00 /bin/bash
    root         8     1  0 11:08 ?        00:00:00 [kjournald]
    ```

12. ## Описание файлов и директории из ProcFS:
```
/proc/PID/cmdline – аргументы командной строки (где PID – идентификатор процесса или self);
/proc/PID/environ – переменные окружения для данного процесса;
/proc/PID/status – статус процесса;
/proc/PID/fd – директория, содержащая символьные ссылки на каждый открытый файловый дескриптор;
/proc/cpuinfo – информация о процессоре (производитель, модель, поколение и т.п.);
/proc/cmdline – параметры, передаваемые ядру при загрузке;
/proc/uptime – количество секунд, прошедших с момента загрузки ядра и проведенных в режиме бездействия;
/proc/version – содержит информацию о версии ядра, компилятора и другую информацию, связанную с загруженным ядром.
/proc/sys/fs/file-max - показывает предел Max Open File Limit (обозначающий число одновременно открытых файлов)
/proc/sys/fs/file-nr - по порядку параметр выдает три значения: число открытых в данный момент файлов; число открытых, но не используемых файлов; максимальное число открытых файлов
```

13. ## Что такое "strace"?
    1. Утилита strace предназначена для отслеживания системных вызовов, которые выполняются процессом в операционной системе Linux. Она позволяет наблюдать взаимодействие между процессом и операционной системой, отслеживая системные вызовы, сигналы, чтение и запись файлов, а также другие операции ввода-вывода.
        1. `strace -p <PID>` - где <PID> - идентификатор процесса, который вы хотите отследить.

# Сети:

14. ## Что такое DNS?
    1. DNS в `k8s`: до version 1.11 - `kube-dns` и после version 1.11 - `CoreDNS`
        1. `resolv.conf`:
        ```
        nameserver 10.32.0.10
        search namespace.svc.cluster.local svc.cluster.local cluster.local
        options ndots:5
        ```
        2. Пример Kubernetes DNS Records:
        ```
        service.namespace.svc.cluster.local

        10.32.0.125.namespace.pod.cluster.local
        ```
        3. Configuration Options - `dnsConfig` option, Updating this config will rewrite a pod’s resolv.conf to enable the changes:
        ```
        apiVersion: v1
        kind: Pod
        metadata:
        namespace: example
        name: custom-dns
        spec:
        containers:
            - name: example
            image: nginx
        dnsPolicy: "None"
        dnsConfig:
            nameservers:
            - 203.0.113.44
            searches:
            - custom.dns.local
        ```
    2. Что такое `DNS`? Domain Name System, — система доменных имён. 
    ```
    IPv4: 82.202.175.68

    IPv6: 2a00:1450:4010:c08::66
    ```
    3. Типы записей в `DNS`:
    ```
    Основные типы ресурсных записей (Resource Records):

    A-запись — задает преобразование имени хоста в IP-адрес.
    MX-запись — определяет почтовый ретранслятор для доменного имени, т.е. узел, который обработает или передаст дальше почтовые сообщения, предназначенные адресату в указанном домене. При наличии нескольких MX-записей сначала происходит попытка доставить почту на ретранслятор с наименьшим приоритетом.
    NS-записи — определяют DNS-серверы, которые являются авторитативными для данной зоны.
    CNAME-запись — определяет отображение псевдонима в каноническое имя узла.
    SRV-запись — позволяет получить имя для искомой службы, а также протокол, по которому эта служба работает.
    TXT-запись — содержит общую текстовую информацию. Эти записи могут использоваться в любых целях, например, для указания месторасположения хоста.
    AAAA-запись — задает преобразование имени хоста в IPV6-адрес.
    SSHFP-запись — используется для хранения слепка ключей SSH в DNS.
    ```

15. ## На каком протоколе транспортного уровня работает DNS?

DNS использует TCP для передачи зоны и UDP в качестве имени и запрашивает обычный (основной) или обратный. UDP можно использовать для обмена небольшой информацией, тогда как протокол TCP должен использоваться для обмена данными размером более 512 байт.

16. ## Разница между TCP и UDP.

TCP (Transmission Control Protocol) и UDP (User Datagram Protocol) - это два основных протокола передачи данных в компьютерных сетях. Они оба используются для передачи данных через сеть, но имеют несколько существенных различий:

1. Надежность передачи данных:
   - TCP обеспечивает надежную передачу данных. Это означает, что он гарантирует, что данные будут доставлены в целости и сохранности, а также в правильном порядке. Если пакет данных потеряется или повреждится в процессе передачи, TCP обеспечивает его повторную отправку.
   - UDP, напротив, является протоколом без установления соединения и не обеспечивает надежную доставку данных. Он отправляет пакеты данных без каких-либо гарантий относительно доставки, порядка или целостности.

2. Управление соединением:
   - TCP устанавливает соединение между отправителем и получателем перед передачей данных и обеспечивает управление этим соединением. Он гарантирует, что данные будут доставлены и в правильном порядке.
   - UDP не устанавливает соединение и не имеет механизмов управления этим соединением. Он просто отправляет пакеты данных и не заботится о дальнейшей обработке.

3. Затраты на передачу данных:
   - Из-за своей надежности и механизмов управления соединением, TCP имеет большие накладные расходы на передачу данных, чем UDP. Это связано с установкой соединения, подтверждениями, контролем потока и т.д.
   - UDP имеет меньшие накладные расходы, так как он просто отправляет пакеты данных без дополнительных проверок и управления.

Итак, TCP обеспечивает надежность и управление соединением, подходящий для приложений, где важна целостность и порядок данных (например, веб-сайты, электронная почта). UDP, с другой стороны, предоставляет более быструю и менее надежную доставку, что подходит для приложений, где небольшие задержки важнее, чем надежность (например, потоковое видео, онлайн-игры).

17. ## TCP ожидает только подтверждения клиента о принятии пакета? Как узнает что пакет целый (Есть такая проверка)?

TCP обеспечивает надежную передачу данных. Это означает, что он гарантирует, что данные будут доставлены в целости и сохранности, а также в правильном порядке. Если пакет данных потеряется или повреждится в процессе передачи, TCP обеспечивает его повторную отправку.

18. ## Как сделано подтверждение в TCP передачи данных и гарантия их сохранности?

TCP обеспечивает надежную передачу данных путем использования механизма подтверждения (acknowledgment). Когда отправитель посылает пакет данных, он ожидает подтверждения от получателя о том, что данные были успешно получены. Если подтверждение не получено в течение определенного времени, отправитель повторно отправляет пакет. Этот процесс гарантирует сохранность данных и правильный порядок их доставки. Таким образом, TCP обеспечивает надежную передачу данных путем повторной отправки потерянных или поврежденных пакетов и использования подтверждений для гарантии доставки данных в целости и сохранности.

19. ## Что такое NAT? В k8s каждый пакет проходит NAT 3-6 раз.

NAT (Network Address Translation) - это процесс замены IP-адресов в заголовках сетевых пакетов при их передаче через маршрутизатор или файрвол. В Kubernetes каждый пакет может пройти через NAT 3-6 раз из-за внутренних переадресаций и преобразований адресов, возникающих при обработке сетевых пакетов внутри кластера.

В Kubernetes (K8s) NAT (Network Address Translation) используется для обеспечения связности и доступности сетевых ресурсов в кластере. NAT в Kubernetes выполняет ряд функций, включая:

1. `Маршрутизацию трафика`: NAT в Kubernetes позволяет маршрутизировать трафик между различными подсетями внутри кластера. Это важно для обеспечения связности между различными компонентами кластера, такими как поды, сервисы, и другие сетевые ресурсы.

2. `Поддержку доступа извне`: NAT также позволяет обеспечить доступ к сетевым ресурсам в кластере из внешних сетей. Это может включать в себя маршрутизацию входящего трафика к сервисам и подам внутри кластера.

3. `Скрытие внутренних IP-адресов`: NAT может использоваться для скрытия внутренних IP-адресов подов и сервисов, что обеспечивает безопасность и конфиденциальность внутренних сетевых ресурсов.

4. `Управление сетевыми ресурсами`: NAT может использоваться для управления сетевыми ресурсами, включая управление доступом и маршрутизацией трафика внутри кластера.

Обычно в Kubernetes NAT может быть реализован с использованием различных инструментов, таких как `iptables`, `ipvs` и другие средства, которые обеспечивают маршрутизацию и перенаправление трафика в сети Kubernetes.

20. ## Пример использования NAT:

Пример использования NAT в Kubernetes (k8s):

В Kubernetes сетевые пакеты могут проходить через NAT при использовании сетевых плагинов, таких как `Calico`, `Flannel` или `Cilium`. Эти плагины могут выполнять NAT для перенаправления трафика между подсетями или для скрытия внутренних IP-адресов подсети от внешнего мира.

Пример использования NAT в Linux:

В Linux NAT может быть использован для перенаправления трафика между сетевыми интерфейсами, скрытия внутренних IP-адресов подсети и преобразования портов для виртуальных хостов. Для работы с NAT в Linux можно использовать утилиту `iptables` для настройки правил NAT, а также программы `ip` и `sysctl` для управления сетевыми параметрами.

Команды, инструменты и объекты для работы с NAT:

В Kubernetes:

Сетевые плагины (например, `Calico`, `Flannel`, `Cilium`) для настройки NAT.
Объекты Kubernetes, такие как Service и Ingress, для управления трафиком и перенаправления.

В Linux:

Утилита `iptables` для настройки правил NAT.
Программы `ip` и `sysctl` для управления сетевыми параметрами.
Файлы конфигурации, такие как `/etc/sysctl.conf` для постоянной настройки параметров NAT.
Для настройки NAT в обоих случаях также могут использоваться специальные контейнеры, которые выполняют функции маршрутизации и преобразования адресов.

21. ## Работал ли с балансировщиками HAProxy, Nginx?

    `HAProxy` и `Nginx` могут использоваться в качестве балансировщиков нагрузки для распределения трафика между несколькими серверами. Они устанавливаются и разворачиваются на серверах с помощью стандартных инструментов управления пакетами, таких как apt или yum для Linux. После установки конфигурируются путем редактирования соответствующих конфигурационных файлов.

    1. Установка `HAProxy`:
    ```
    sudo apt-get update
    sudo apt-get install haproxy
    ```

    2. Конфигурирование HAProxy:
    Конфигурационные файлы HAProxy обычно настраиваются в файле /etc/haproxy/haproxy.cfg. В этом файле определяются настройки балансировки нагрузки, такие как адреса серверов, порты, алгоритмы балансировки и т. д.

    3. После внесения изменений в конфигурационный файл HAProxy перезапускается для применения изменений:
    ```
    sudo systemctl restart haproxy
    ```

    Пример использования Nginx в Kubernetes:

    1. Установка Nginx в Kubernetes:
    Nginx может быть использован как балансировщик нагрузки в Kubernetes с помощью Ingress Controller, такого как Nginx Ingress Controller. Установка Ingress Controller может быть выполнена с использованием Helm:
    ```
    helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
    helm install my-release ingress-nginx/ingress-nginx
    ```

    2. Конфигурирование Nginx в Kubernetes:
    После установки Ingress Controller, конфигурация балансировки нагрузки определяется с помощью Ingress-ресурсов Kubernetes, которые определяют правила маршрутизации трафика на службы внутри кластера.

22. ## Перечислить список типов объектов в Kubernetes.

    1. `Pod`:
    Представляет собой наименьшую единицу развертывания в Kubernetes, содержащую один или несколько контейнеров.

    2. `Service`:
    Определяет набор подов и политику доступа к ним, создавая стабильные конечные точки для взаимодействия.

    3. `Volume`:
    Предоставляет постоянное хранилище для данных, доступное для подов в Kubernetes.

    4. `Namespace`:
    Используется для группировки ресурсов и управления доступом к ним внутри кластера.

    5. `ConfigMap`:
    Хранит конфигурационные данные, такие как параметры и настройки, которые могут быть использованы в приложениях.

    6. `Secret`:
    Содержит конфиденциальную информацию, такую как пароли, ключи API и сертификаты, обеспечивая их безопасное хранение и использование.

    7. `PersistentVolume`:
    Предоставляет управляемое постоянное хранилище, которое может быть использовано независимо от жизненного цикла подов.

    8. `PersistentVolumeClaim`:
    Запрос на использование постоянного хранилища, который позволяет подам получать доступ к PersistentVolume.

    9. `StorageClass`:
    Определяет класс хранилища, предоставляемый для PersistentVolume, включая параметры такие как тип хранилища и провайдер.

    10. `StatefulSet`:
    Управляет развертыванием и масштабированием приложений с постоянными и уникальными идентификаторами.

    11. `DaemonSet`:
    Обеспечивает запуск экземпляра пода на каждом узле в кластере.

    12. `ReplicaSet`:
    Обеспечивает желаемое количество реплик подов, обеспечивая их непрерывную работу.

    13. `Deployment`:
    Определяет желаемое состояние подов и контролирует их жизненный цикл, позволяя обновлять и масштабировать приложения.

    14. `Job`:
    Управляет выполнением задач, которые должны быть выполнены только один раз.

    15. `CronJob`:
    Позволяет запускать задачи периодически в установленное время.

    16. `Ingress`:
    Управляет внешним доступом к службам внутри кластера Kubernetes, позволяя настраивать маршрутизацию HTTP и HTTPS-трафика.

    17. `NetworkPolicy`:
    Определяет правила безопасности для сетевого трафика между подами и службами в кластере.

    18. `ServiceAccount`:
    Предоставляет идентификацию и авторизацию для подов в Kubernetes.

23. ## Назвать разницу между Deployment и StatefulSet.

    `Deployment` предназначен для управления развертыванием и масштабированием приложений с учетом непрерывной поставки и обновления.
    Поды, создаваемые с помощью Deployment, имеют уникальные идентификаторы, но не сохраняют постоянное состояние.
    При обновлении Deployment, новые версии приложений могут быть развернуты параллельно с текущими версиями, и после успешного развертывания новой версии, старые версии могут быть постепенно уничтожены.

    `StatefulSet` предназначен для управления развертыванием приложений, которые требуют уникальных и постоянных идентификаторов, таких как базы данных или другие приложения, хранящие постоянные данные.
    Поды, создаваемые с помощью StatefulSet, имеют уникальные и постоянные идентификаторы, что позволяет им сохранять свое состояние и поддерживать уникальные идентификаторы даже в случае перезапуска или масштабирования.
    StatefulSet также обеспечивает управление порядком запуска и остановки подов, что важно для приложений, зависящих от порядка инициализации или остановки.
    Таким образом, основное различие между Deployment и StatefulSet заключается в их способности обращаться с подами и обеспечивать сохранение состояния. Deployment предназначен для управления масштабируемыми приложениями без сохранения состояния, в то время как StatefulSet предназначен для управления приложениями, которые требуют уникальных и постоянных идентификаторов и поддержания состояния.

24. ## Рассказать что такое POD в k8s.

    Pod в Kubernetes - это наименьшая и базовая единица, которая представляет собой группу одного или нескольких контейнеров, которые работают вместе на одном узле. Контейнеры внутри Pod'a разделяют одинаковый набор ресурсов, таких как сеть и хранилище, и могут обмениваться информацией через общие тома.

    Основная разница между Pod'ом, виртуальной машиной и контейнером заключается в их уровне абстракции и изоляции:

    Контейнеры - это приложения, которые работают в изолированной среде, используя общие ресурсы операционной системы. Они легковесны и быстро запускаются, но не обеспечивают полной изоляции от других контейнеров на узле.

    Виртуальные машины - это полная виртуализация, где каждая ВМ имеет свою собственную операционную систему и оборудование, и работает в изолированной среде. ВМ более изолированы от других ВМ на узле, но требуют больше ресурсов и медленнее запускаются.

    Pod в Kubernetes - это группа контейнеров, которые работают в изолированной среде, используя общие ресурсы узла. Pod обеспечивает более высокий уровень изоляции, чем контейнеры, но более низкий, чем виртуальные машины.

    Таким образом, Pod в Kubernetes - это уровень абстракции между контейнером и виртуальной машиной, который обеспечивает изоляцию и общие ресурсы для группы контейнеров, работающих вместе на одном узле.

# Ansible, CI/CD:

25. ## Что такое Ansible и что делал на нём?

